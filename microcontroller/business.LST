C51 COMPILER V9.00   BUSINESS                                                              04/24/2016 01:25:51 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE BUSINESS
OBJECT MODULE PLACED IN business.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE business.c ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "user_sys.h"
   2          #include "uart.h"
   3          #include "business.h"
   4          #include <string.h>
   5          #include <stdio.h>
   6          #include <reg52.h>
   7          #include "phy.h"
   8          
   9          #define LOCKER_TIMER 7
  10          
  11          extern app_Event getApp;
  12          
  13          extern uint8 uartData[20];
  14          extern uint8 uartIndex;
  15          
  16          
  17          //uint8 code table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};//不带小数点的共阴数码管段值
  18          //uint8 code table[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
  19          sbit lockerPin=P1^7;    //定义位选
  20          
  21          int timer;
  22          
  23          typedef enum{
  24                  LOCK,
  25                  UNLOCK
  26          }LOCKER_STATUS;
  27          
  28          LOCKER_STATUS lockerStatus = LOCK;
  29          
  30          
  31          
  32          void userBusinessEventHandle()
  33          {
  34   1              uint8 i;
  35   1              for(i=0;i<EVENT_NUMBER;i++)
  36   1              {
  37   2                      if((getApp.eventEDable_t[i]==ENABLE)&&(getApp.eventResultFlag_t[i]==ENABLE)&&(getApp.eventDoCount_t[i]<g
             -etApp.eventSetCount_t[i]))
  38   2                      {
  39   3                              userSystemSetEventDone(i);
  40   3                              switch(getApp.eventId_t[i])
  41   3                              {
  42   4                                      case EVENT_UART_RECIVE:
  43   4                                      {
  44   5                                              uartSendStr(uartData);
  45   5                                              dealLocker(uartData);
  46   5                                              uartDataClean();
  47   5                                              setEvent(EVENT_UART_RECIVE, ENABLE,20,1);
  48   5                                      }
  49   4                                      break;
  50   4                                      case EVENT_LOCK_LOCKER:
  51   4                                      {
  52   5                                              lockerStatus = UNLOCK;
  53   5                                              reportLockerStatus();
  54   5                                              uartSendStr("UNLOCK\r\n");
C51 COMPILER V9.00   BUSINESS                                                              04/24/2016 01:25:51 PAGE 2   

  55   5                                      }
  56   4                                      break;
  57   4                                      case EVENT_LOCKER_STATUS_RSP:
  58   4                                      {
  59   5                                              reportLockerStatus();
  60   5                                              setEvent(EVENT_LOCKER_STATUS_RSP, ENABLE,3000,1);
  61   5                                      }
  62   4                                      break;
  63   4                                      /*锁倒计时*/
  64   4                                      case EVENT_LOCKER_DAOJISHI:
  65   4                                      {
  66   5                                              
  67   5                              
  68   5      
  69   5                                                      
  70   5      
  71   5                                              /*if(timer < -1)
  72   5                                              {
  73   5                                                      timer =LOCKER_TIMER;
  74   5                                                      setEvent(EVENT_LOCKER_LOCKED, ENABLE,1,1);
  75   5                                                      setEvent(EVENT_LOCKER_DAOJISHI, DISABLE,0,0);
  76   5                                                      lockerStatus = LOCK;
  77   5                                                      reportLockerStatus();
  78   5                                              }
  79   5                                              else
  80   5                                              {                                       
  81   5                                                      uartSendStr("EVENT_LOCKER_DAOJISHI\r\n");
  82   5                                                      setEvent(EVENT_LOCKER_DAOJISHI, ENABLE,200,1);
  83   5                                                      lockerStatus = UNLOCK;
  84   5                                                      reportLockerStatus();                                           
  85   5                                              }*/
  86   5                                      }
  87   4                                      break;
  88   4                                      case EVENT_LOCKER_LOCKED:
  89   4      
  90   4                                              break;
  91   4                                      case EVENT_SEGMENT_DISPLAYER:
  92   4                                              dealSegmentDisplays();
  93   4                                              break;
  94   4                                      default:
  95   4                                              break;
  96   4                              
  97   4                              }
  98   3                      }
  99   2                      else if((getApp.eventEDable_t[i]==ENABLE)&&(getApp.eventDoCount_t[i]>=getApp.eventSetCount_t[i]))
 100   2                      {
 101   3                              getApp.eventEDable_t[i]=DISABLE;
 102   3                      }
 103   2              }
 104   1      }
 105          
 106          void dealLocker(uint8 *cmd)
 107          {
 108   1              if(uartIndex < 5 ) return;
 109   1              if(uartIndex == 0) return;
 110   1              
 111   1              if((cmd[0] == 'U')&&(cmd[1] == 'N')&&cmd[2] == 'L'&&cmd[3] == 'O'&&cmd[4] == 'C'&&cmd[5] == 'K'){
 112   2                      lockerPin = 1;
 113   2                      timer = LOCKER_TIMER;
 114   2                      uartSendStr("open locker 5s\r\n");
 115   2                      lockerStatus = UNLOCK;
 116   2                      reportLockerStatus();
C51 COMPILER V9.00   BUSINESS                                                              04/24/2016 01:25:51 PAGE 3   

 117   2                      //setEvent(EVENT_LOCK_LOCKER, ENABLE,500,1);
 118   2                      setEvent(EVENT_LOCKER_DAOJISHI, ENABLE,1,1);
 119   2              }
 120   1              if((cmd[0] == 'T')&&(cmd[1] == 'O')&&cmd[2] == 'L'&&cmd[3] == 'O'&&cmd[4] == 'C'&&cmd[5] == 'K'){
 121   2      
 122   2                      timer = 0;
 123   2                      lockerStatus = LOCK;
 124   2                      reportLockerStatus();
 125   2                      setEvent(EVENT_LOCKER_LOCKED, ENABLE,1,1);
 126   2                      setEvent(EVENT_LOCKER_DAOJISHI, DISABLE,0,0);
 127   2              }
 128   1      }
 129          void reportLockerStatus()
 130          {
 131   1              if(lockerStatus == UNLOCK)
 132   1              {
 133   2                      lockerPin = 1;
 134   2                      uartSendStr("unlock\r\n");
 135   2              }
 136   1              else
 137   1              {
 138   2                      lockerPin = 0;
 139   2                      uartSendStr("lock\r\n");
 140   2              }
 141   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    432    ----
   CONSTANT SIZE    =     42    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
